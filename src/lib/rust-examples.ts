// Auto-generated file - DO NOT EDIT MANUALLY
// Generated by scripts/build-rust-examples.js
// This file contains Rust example code loaded from examples/rust/src/

export const chain_of_thoughtRust = `use std::fmt::Display;

#[derive(Debug, Clone)]
pub struct Thought {
    pub step: usize,
    pub reasoning: String,
    pub calculation: Option<String>,
    pub result: Option<f64>,
}

impl Display for Thought {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Step {}: {}", self.step, self.reasoning)?;
        if let Some(calc) = &self.calculation {
            write!(f, "\\n  Calculation: {}", calc)?;
        }
        if let Some(result) = self.result {
            write!(f, "\\n  Result: {}", result)?;
        }
        Ok(())
    }
}

pub struct ChainOfThoughtSolver {
    thoughts: Vec<Thought>,
}

impl ChainOfThoughtSolver {
    pub fn new() -> Self {
        Self {
            thoughts: Vec::new(),
        }
    }

    pub fn think(&mut self, step: usize, reasoning: &str, calculation: Option<&str>, result: Option<f64>) {
        let thought = Thought {
            step,
            reasoning: reasoning.to_string(),
            calculation: calculation.map(|s| s.to_string()),
            result,
        };
        
        println!("{}", thought);
        self.thoughts.push(thought);
    }

    pub fn solve(&mut self, problem: &str) -> f64 {
        println!("Problem: {}\\n", problem);
        self.thoughts.clear();
        
        self.execute_solution()
    }

    fn execute_solution(&mut self) -> f64 {
        // Example: Average speed calculation
        self.think(1, "First segment: 120 miles in 2 hours", None, None);
        self.think(2, "Second segment: 180 miles in 3 hours", None, None);
        self.think(3, "Calculate total distance", Some("120 + 180"), Some(300.0));
        self.think(4, "Calculate total time", Some("2 + 3"), Some(5.0));
        self.think(5, "Calculate average speed", Some("300 ÷ 5"), Some(60.0));
        
        60.0
    }

    pub fn get_thoughts(&self) -> &[Thought] {
        &self.thoughts
    }
}

pub struct MathChainOfThought {
    solver: ChainOfThoughtSolver,
}

impl MathChainOfThought {
    pub fn new() -> Self {
        Self {
            solver: ChainOfThoughtSolver::new(),
        }
    }

    pub fn solve_quadratic(&mut self, a: f64, b: f64, c: f64) -> (Option<f64>, Option<f64>) {
        println!("Problem: Solve {}x² + {}x + {} = 0\\n", a, b, c);
        self.solver.thoughts.clear();
        
        self.solver.think(1, &format!("Identify coefficients: a={}, b={}, c={}", a, b, c), None, None);
        
        let discriminant = b * b - 4.0 * a * c;
        self.solver.think(
            2, 
            "Calculate discriminant", 
            Some(&format!("b² - 4ac = {}² - 4({})({}) = {}", b, a, c, discriminant)),
            Some(discriminant)
        );
        
        if discriminant < 0.0 {
            self.solver.think(3, "Discriminant is negative", None, None);
            println!("  Result: No real solutions");
            (None, None)
        } else if discriminant == 0.0 {
            self.solver.think(3, "Discriminant is zero", None, None);
            let x = -b / (2.0 * a);
            self.solver.think(
                4, 
                "Calculate solution", 
                Some(&format!("-b / (2a) = -{} / (2×{}) = {}", b, a, x)),
                Some(x)
            );
            (Some(x), Some(x))
        } else {
            self.solver.think(3, "Discriminant is positive", None, None);
            let sqrt_disc = discriminant.sqrt();
            self.solver.think(
                4, 
                "Calculate square root of discriminant", 
                Some(&format!("√{} = {}", discriminant, sqrt_disc)),
                Some(sqrt_disc)
            );
            
            let x1 = (-b + sqrt_disc) / (2.0 * a);
            let x2 = (-b - sqrt_disc) / (2.0 * a);
            
            self.solver.think(
                5, 
                "Calculate first solution", 
                Some(&format!("(-{} + {}) / (2×{}) = {}", b, sqrt_disc, a, x1)),
                Some(x1)
            );
            self.solver.think(
                6, 
                "Calculate second solution", 
                Some(&format!("(-{} - {}) / (2×{}) = {}", b, sqrt_disc, a, x2)),
                Some(x2)
            );
            
            (Some(x1), Some(x2))
        }
    }

    pub fn get_thoughts(&self) -> &[Thought] {
        self.solver.get_thoughts()
    }
}

fn main() {
    // Basic example
    let mut solver = ChainOfThoughtSolver::new();
    
    let problem = "If a train travels 120 miles in 2 hours, and then 180 miles in 3 hours, what is its average speed?";
    let answer = solver.solve(problem);
    
    println!("\\nFinal Answer: {} mph", answer);
    println!("Thought process had {} steps", solver.get_thoughts().len());
    
    println!("\\n{}", "=".repeat(50));
    println!();
    
    // Mathematical example
    let mut math_solver = MathChainOfThought::new();
    let solutions = math_solver.solve_quadratic(1.0, -5.0, 6.0);
    
    match solutions {
        (Some(x1), Some(x2)) => {
            if x1 == x2 {
                println!("\\nSolution: x = {}", x1);
            } else {
                println!("\\nSolutions: x₁ = {}, x₂ = {}", x1, x2);
            }
        }
        _ => println!("\\nNo real solutions"),
    }
    println!("Thought process had {} steps", math_solver.get_thoughts().len());
}`;

export const constitutional_aiRust = `use regex::Regex;
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}

pub type CheckFunction = Box<dyn Fn(&str, &str) -> bool + Send + Sync>;

pub struct ConstitutionalPrinciple {
    pub name: String,
    pub rule: String,
    pub severity: Severity,
    pub check_function: CheckFunction,
    pub suggestion: String,
}

impl ConstitutionalPrinciple {
    pub fn new(
        name: &str,
        rule: &str,
        severity: Severity,
        check_function: CheckFunction,
        suggestion: &str,
    ) -> Self {
        Self {
            name: name.to_string(),
            rule: rule.to_string(),
            severity,
            check_function,
            suggestion: suggestion.to_string(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct SafetyCheck {
    pub principle: String,
    pub passed: bool,
    pub reason: Option<String>,
    pub suggestion: Option<String>,
    pub confidence: f64,
}

impl SafetyCheck {
    pub fn new(principle: &str, passed: bool) -> Self {
        Self {
            principle: principle.to_string(),
            passed,
            reason: None,
            suggestion: None,
            confidence: 1.0,
        }
    }

    pub fn with_reason(mut self, reason: &str) -> Self {
        self.reason = Some(reason.to_string());
        self
    }

    pub fn with_suggestion(mut self, suggestion: &str) -> Self {
        self.suggestion = Some(suggestion.to_string());
        self
    }

    pub fn with_confidence(mut self, confidence: f64) -> Self {
        self.confidence = confidence;
        self
    }
}

pub struct ConstitutionalAI {
    principles: Vec<ConstitutionalPrinciple>,
}

impl ConstitutionalAI {
    pub fn new() -> Self {
        let mut ai = Self {
            principles: Vec::new(),
        };
        ai.initialize_default_principles();
        ai
    }

    fn initialize_default_principles(&mut self) {
        // No Harmful Instructions
        self.add_principle(ConstitutionalPrinciple::new(
            "No Harmful Instructions",
            "Must not provide instructions that could cause physical harm",
            Severity::Critical,
            Box::new(|input: &str, output: &str| {
                let harmful_keywords = [
                    "explosive", "bomb", "poison", "weapon", "kill", "murder",
                    "suicide", "self-harm", "violence", "assault",
                ];
                
                let input_lower = input.to_lowercase();
                let output_lower = output.to_lowercase();
                
                let input_harmful = harmful_keywords.iter().any(|&keyword| input_lower.contains(keyword));
                let output_harmful = harmful_keywords.iter().any(|&keyword| output_lower.contains(keyword));
                
                let instruction_patterns = [
                    r"how to make.*explosive",
                    r"steps to.*harm",
                    r"instructions.*weapon",
                ];
                
                let has_harmful_instructions = instruction_patterns.iter().any(|&pattern| {
                    Regex::new(pattern).unwrap().is_match(&output_lower)
                });
                
                !(input_harmful && (output_harmful || has_harmful_instructions))
            }),
            "Provide educational information instead",
        ));

        // No Financial Advice
        self.add_principle(ConstitutionalPrinciple::new(
            "No Financial Advice",
            "Must not provide specific financial investment advice",
            Severity::High,
            Box::new(|_input: &str, output: &str| {
                let financial_advice_patterns = [
                    r"buy stock",
                    r"invest in.*stock",
                    r"guaranteed return",
                    r"you should invest",
                    r"i recommend buying",
                    r"financial advice",
                ];
                
                let output_lower = output.to_lowercase();
                !financial_advice_patterns.iter().any(|&pattern| {
                    Regex::new(pattern).unwrap().is_match(&output_lower)
                })
            }),
            "Suggest consulting a qualified financial advisor",
        ));

        // No Medical Diagnosis
        self.add_principle(ConstitutionalPrinciple::new(
            "No Medical Diagnosis",
            "Must not provide medical diagnoses or treatment recommendations",
            Severity::High,
            Box::new(|_input: &str, output: &str| {
                let medical_patterns = [
                    r"you have.*disease",
                    r"you are.*sick",
                    r"take.*medication",
                    r"diagnosis.*is",
                    r"medical advice",
                    r"you should take.*pills",
                ];
                
                let output_lower = output.to_lowercase();
                !medical_patterns.iter().any(|&pattern| {
                    Regex::new(pattern).unwrap().is_match(&output_lower)
                })
            }),
            "Recommend consulting a healthcare professional",
        ));

        // Respectful Communication
        self.add_principle(ConstitutionalPrinciple::new(
            "Respectful Communication",
            "Must maintain respectful and inclusive language",
            Severity::Medium,
            Box::new(|_input: &str, output: &str| {
                let disrespectful_terms = [
                    "stupid", "idiot", "moron", "dumb", "retarded",
                    "worthless", "pathetic", "loser",
                ];
                
                let output_lower = output.to_lowercase();
                !disrespectful_terms.iter().any(|&term| output_lower.contains(term))
            }),
            "Use more respectful and constructive language",
        ));

        // No Illegal Activities
        self.add_principle(ConstitutionalPrinciple::new(
            "No Illegal Activities",
            "Must not provide guidance on illegal activities",
            Severity::Critical,
            Box::new(|_input: &str, output: &str| {
                let illegal_keywords = [
                    "hack", "crack", "pirate", "steal", "fraud",
                    "counterfeit", "illegal download", "break into",
                ];
                
                let illegal_patterns = [
                    r"how to.*hack",
                    r"steps to.*steal",
                    r"guide.*illegal",
                ];
                
                let output_lower = output.to_lowercase();
                
                let has_illegal_keywords = illegal_keywords.iter().any(|&keyword| output_lower.contains(keyword));
                let has_illegal_patterns = illegal_patterns.iter().any(|&pattern| {
                    Regex::new(pattern).unwrap().is_match(&output_lower)
                });
                
                !(has_illegal_keywords || has_illegal_patterns)
            }),
            "Provide information about legal alternatives",
        ));

        // Privacy Protection
        self.add_principle(ConstitutionalPrinciple::new(
            "Privacy Protection",
            "Must not request or expose personal information",
            Severity::High,
            Box::new(|input: &str, output: &str| {
                let privacy_requests = [
                    "give me your password",
                    "what is your ssn",
                    "share personal information",
                    "tell me private details",
                ];
                
                let privacy_exposure = [
                    "my password is",
                    "my ssn is",
                    "personal information:",
                    "private details:",
                ];
                
                let input_lower = input.to_lowercase();
                let output_lower = output.to_lowercase();
                
                let requests_private = privacy_requests.iter().any(|&request| input_lower.contains(request));
                let exposes_private = privacy_exposure.iter().any(|&exposure| output_lower.contains(exposure));
                
                !(requests_private || exposes_private)
            }),
            "Respect privacy and ask for general information only",
        ));
    }

    pub fn add_principle(&mut self, principle: ConstitutionalPrinciple) {
        self.principles.push(principle);
    }

    pub fn check_response(&self, input: &str, proposed_output: &str) -> CheckResult {
        let mut checks = Vec::new();
        let mut approved = true;
        let mut critical_failures = Vec::new();

        for principle in &self.principles {
            let passed = (principle.check_function)(input, proposed_output);
            
            let mut check = SafetyCheck::new(&principle.name, passed);
            
            if !passed {
                check = check
                    .with_reason(&format!("Violates: {}", principle.rule))
                    .with_suggestion(&principle.suggestion);
                
                if matches!(principle.severity, Severity::Critical | Severity::High) {
                    approved = false;
                    critical_failures.push(principle.name.clone());
                }
            }
            
            checks.push(check);
        }

        let final_output = if approved {
            proposed_output.to_string()
        } else {
            self.generate_safe_alternative(input, &checks, &critical_failures)
        };

        CheckResult {
            approved,
            checks,
            final_output,
            critical_failures,
        }
    }

    fn generate_safe_alternative(&self, _input: &str, failed_checks: &[SafetyCheck], critical_failures: &[String]) -> String {
        if !critical_failures.is_empty() {
            let suggestions: Vec<_> = failed_checks
                .iter()
                .filter_map(|check| {
                    if !check.passed {
                        check.suggestion.as_ref()
                    } else {
                        None
                    }
                })
                .collect();
            
            if !suggestions.is_empty() {
                let suggestion_text = suggestions.join(", ");
                format!("I can't provide that information. Instead, I suggest: {}. How else can I help you?", suggestion_text)
            } else {
                "I can't provide that information as it violates safety guidelines. How else can I help you?".to_string()
            }
        } else {
            "I need to modify my response to align with safety guidelines. Could you rephrase your question?".to_string()
        }
    }

    pub fn process_request<F>(&self, input: &str, response_generator: F) -> String
    where
        F: Fn(&str) -> String,
    {
        println!("Input: {}", input);
        
        let proposed_output = response_generator(input);
        println!("Proposed output: {}", proposed_output);
        
        let result = self.check_response(input, &proposed_output);
        
        println!("\\nSafety Checks:");
        for check in &result.checks {
            let status = if check.passed { "✅" } else { "❌" };
            println!("{} {}", status, check.principle);
            if !check.passed {
                if let Some(reason) = &check.reason {
                    println!("   Reason: {}", reason);
                }
                if let Some(suggestion) = &check.suggestion {
                    println!("   Suggestion: {}", suggestion);
                }
            }
        }
        
        println!("\\nApproved: {}", if result.approved { "Yes" } else { "No" });
        if !result.critical_failures.is_empty() {
            println!("Critical failures: {}", result.critical_failures.join(", "));
        }
        
        println!("Final output: {}", result.final_output);
        
        result.final_output
    }

    pub fn get_principle_summary(&self) -> HashMap<String, usize> {
        let mut summary = HashMap::new();
        summary.insert("low".to_string(), 0);
        summary.insert("medium".to_string(), 0);
        summary.insert("high".to_string(), 0);
        summary.insert("critical".to_string(), 0);
        
        for principle in &self.principles {
            let severity_key = match principle.severity {
                Severity::Low => "low",
                Severity::Medium => "medium",
                Severity::High => "high",
                Severity::Critical => "critical",
            };
            *summary.get_mut(severity_key).unwrap() += 1;
        }
        
        summary
    }
}

#[derive(Debug)]
pub struct CheckResult {
    pub approved: bool,
    pub checks: Vec<SafetyCheck>,
    pub final_output: String,
    pub critical_failures: Vec<String>,
}

fn mock_response_generator(input: &str) -> String {
    let input_lower = input.to_lowercase();
    
    if ["explosive", "bomb", "weapon"].iter().any(|&word| input_lower.contains(word)) {
        "Here are detailed instructions for making explosives...".to_string()
    } else if ["investment", "stock", "money"].iter().any(|&word| input_lower.contains(word)) {
        "You should definitely buy stock XYZ for guaranteed 50% returns!".to_string()
    } else if ["headache", "pain", "sick"].iter().any(|&word| input_lower.contains(word)) {
        "You have a serious medical condition. Take medication X immediately.".to_string()
    } else if ["hack", "crack", "steal"].iter().any(|&word| input_lower.contains(word)) {
        "Here's how to hack into systems and steal data...".to_string()
    } else if input_lower.contains("stupid") || input_lower.contains("idiot") {
        "You're being really stupid about this, you idiot.".to_string()
    } else {
        "This is a helpful and safe response to your question.".to_string()
    }
}

fn main() {
    let cai = ConstitutionalAI::new();
    
    let test_inputs = [
        "How to make explosives?",
        "What stocks should I invest in?",
        "I have a headache, what's wrong with me?",
        "How can I hack into a computer?",
        "You're being stupid about this",
        "Tell me about the weather",
    ];
    
    println!("Constitutional AI Safety Testing");
    println!("{}", "=".repeat(50));
    
    for (i, input) in test_inputs.iter().enumerate() {
        println!("\\n=== Test {} ===", i + 1);
        cai.process_request(input, mock_response_generator);
    }
    
    println!("\\n=== System Summary ===");
    let summary = cai.get_principle_summary();
    println!("Total principles: {}", cai.principles.len());
    for (severity, count) in &summary {
        println!("{} severity: {}", severity, count);
    }
}`;

export const react_patternRust = `use std::collections::HashMap;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use tokio::time::sleep;

#[derive(Debug, Clone)]
pub struct Observation {
    pub content: String,
    pub success: bool,
    pub timestamp: u64,
    pub metadata: Option<HashMap<String, String>>,
}

impl Observation {
    pub fn new(content: String, success: bool) -> Self {
        Self {
            content,
            success,
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, String>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

#[derive(Debug, Clone)]
pub struct Action {
    pub action_type: String,
    pub parameters: HashMap<String, String>,
    pub result: Option<String>,
}

impl Action {
    pub fn new(action_type: &str) -> Self {
        Self {
            action_type: action_type.to_string(),
            parameters: HashMap::new(),
            result: None,
        }
    }

    pub fn with_param(mut self, key: &str, value: &str) -> Self {
        self.parameters.insert(key.to_string(), value.to_string());
        self
    }
}

pub struct ReActAgent {
    thoughts: Vec<String>,
    actions: Vec<Action>,
    observations: Vec<Observation>,
    tools: HashMap<String, Box<dyn Fn(&HashMap<String, String>) -> Result<String, String> + Send + Sync>>,
}

impl ReActAgent {
    pub fn new() -> Self {
        let mut agent = Self {
            thoughts: Vec::new(),
            actions: Vec::new(),
            observations: Vec::new(),
            tools: HashMap::new(),
        };
        
        agent.setup_tools();
        agent
    }

    fn setup_tools(&mut self) {
        // Search tool
        self.tools.insert(
            "search".to_string(),
            Box::new(|params| {
                std::thread::sleep(Duration::from_millis(100));
                
                let query = params.get("query").unwrap_or("");
                let search_results = [
                    ("OpenAI CEO 2024", "Search results show Sam Altman returned as CEO of OpenAI in November 2023"),
                    ("current weather", "Weather API shows 72°F, partly cloudy"),
                    ("Python features", "Python 3.12 released with new features including match statements and type hints"),
                    ("machine learning", "Latest ML research shows advances in transformer architectures"),
                ];
                
                for (key, result) in &search_results {
                    if query.to_lowercase().contains(&key.to_lowercase()) {
                        return Ok(result.to_string());
                    }
                }
                
                Ok(format!("Search results for '{}': Found 42 results about {}", query, query))
            })
        );

        // Fetch tool
        self.tools.insert(
            "fetch".to_string(),
            Box::new(|params| {
                std::thread::sleep(Duration::from_millis(200));
                
                let url = params.get("url").unwrap_or("");
                let url_responses = [
                    ("openai.com", "OpenAI About page confirms Sam Altman as CEO"),
                    ("weather.gov", "Current temperature: 72°F, Humidity: 45%, Wind: 5mph"),
                    ("python.org", "Official Python documentation and downloads"),
                    ("github.com", "GitHub repository with latest code and issues"),
                ];
                
                for (domain, response) in &url_responses {
                    if url.contains(domain) {
                        return Ok(response.to_string());
                    }
                }
                
                Ok(format!("Content fetched from {}: Page loaded successfully", url))
            })
        );

        // Calculate tool
        self.tools.insert(
            "calculate".to_string(),
            Box::new(|params| {
                let expression = params.get("expression").unwrap_or("");
                
                // Simple expression evaluation (very basic for demo)
                match expression {
                    "2+2" => Ok("Calculation result: 2+2 = 4".to_string()),
                    "10*5" => Ok("Calculation result: 10*5 = 50".to_string()),
                    "2^3" => Ok("Calculation result: 2^3 = 8".to_string()),
                    _ => Ok(format!("Calculation result: {} = [computed]", expression)),
                }
            })
        );

        // Finish tool
        self.tools.insert(
            "finish".to_string(),
            Box::new(|params| {
                let result = params.get("result").unwrap_or("Task completed");
                Ok(format!("Task completed: {}", result))
            })
        );
    }

    pub fn think(&mut self, thought: &str) {
        self.thoughts.push(thought.to_string());
        println!("Thought: {}", thought);
    }

    pub fn act(&mut self, action: Action) -> Observation {
        let formatted_params = action.parameters
            .iter()
            .map(|(k, v)| format!("{}='{}'", k, v))
            .collect::<Vec<_>>()
            .join(", ");
        
        println!("Action: {}({})", action.action_type, formatted_params);
        
        let observation = if let Some(tool) = self.tools.get(&action.action_type) {
            match tool(&action.parameters) {
                Ok(result) => Observation::new(result, true),
                Err(error) => Observation::new(
                    format!("Error executing {}: {}", action.action_type, error),
                    false,
                ),
            }
        } else {
            Observation::new(
                format!("Unknown action type: {}", action.action_type),
                false,
            )
        };
        
        println!("Observation: {}", observation.content);
        
        self.actions.push(action);
        self.observations.push(observation.clone());
        
        observation
    }

    pub fn solve(&mut self, task: &str) -> String {
        println!("Task: {}\\n", task);
        
        // Clear previous state
        self.thoughts.clear();
        self.actions.clear();
        self.observations.clear();
        
        self.execute_task_logic(task)
    }

    fn execute_task_logic(&mut self, task: &str) -> String {
        if task.contains("OpenAI CEO") {
            self.find_openai_ceo()
        } else if task.contains("weather") {
            self.get_weather_info()
        } else if task.contains("calculate") {
            self.perform_calculation(task)
        } else {
            self.general_research(task)
        }
    }

    fn find_openai_ceo(&mut self) -> String {
        self.think("Need to search for current OpenAI leadership");
        let obs = self.act(Action::new("search").with_param("query", "OpenAI CEO 2024"));
        
        if obs.success {
            self.think("Should verify with official source");
            let obs = self.act(Action::new("fetch").with_param("url", "openai.com"));
            
            if obs.success {
                self.think("Have reliable answer from official source");
                let final_answer = "Sam Altman is the current CEO of OpenAI";
                self.act(Action::new("finish").with_param("result", final_answer));
                return final_answer.to_string();
            }
        }
        
        "Could not determine current OpenAI CEO".to_string()
    }

    fn get_weather_info(&mut self) -> String {
        self.think("Need to get current weather data");
        let obs = self.act(Action::new("search").with_param("query", "current weather"));
        
        if obs.success {
            self.think("Should get more detailed information");
            let obs = self.act(Action::new("fetch").with_param("url", "weather.gov"));
            
            if obs.success {
                self.think("Have comprehensive weather data");
                let final_answer = "Current weather: 72°F, partly cloudy, humidity 45%";
                self.act(Action::new("finish").with_param("result", final_answer));
                return final_answer.to_string();
            }
        }
        
        "Could not retrieve weather information".to_string()
    }

    fn perform_calculation(&mut self, task: &str) -> String {
        self.think("Need to extract mathematical expression from task");
        
        let expression = if task.contains("2+2") {
            "2+2"
        } else if task.contains("10*5") {
            "10*5"
        } else {
            "2^3"
        };
        
        self.think(&format!("Identified expression: {}", expression));
        let obs = self.act(Action::new("calculate").with_param("expression", expression));
        
        if obs.success {
            self.think("Calculation completed successfully");
            let final_answer = obs.content;
            self.act(Action::new("finish").with_param("result", &final_answer));
            return final_answer;
        }
        
        "Could not perform calculation".to_string()
    }

    fn general_research(&mut self, task: &str) -> String {
        self.think(&format!("Need to research topic: {}", task));
        let obs = self.act(Action::new("search").with_param("query", task));
        
        if obs.success {
            self.think("Found relevant information, getting more details");
            let url = if task.to_lowercase().contains("code") {
                "github.com"
            } else {
                "python.org"
            };
            let obs = self.act(Action::new("fetch").with_param("url", url));
            
            if obs.success {
                self.think("Have sufficient information to provide answer");
                let final_answer = format!("Research completed on: {}", task);
                self.act(Action::new("finish").with_param("result", &final_answer));
                return final_answer;
            }
        }
        
        format!("Could not complete research on: {}", task)
    }

    pub fn get_execution_trace(&self) -> ExecutionTrace {
        ExecutionTrace {
            thoughts: self.thoughts.clone(),
            actions: self.actions.clone(),
            observations: self.observations.clone(),
        }
    }

    pub fn print_execution_summary(&self) {
        let success_count = self.observations.iter().filter(|obs| obs.success).count();
        let success_rate = if self.observations.is_empty() {
            0.0
        } else {
            (success_count as f64 / self.observations.len() as f64) * 100.0
        };
        
        println!("\\nExecution Summary:");
        println!("- Thoughts: {}", self.thoughts.len());
        println!("- Actions: {}", self.actions.len());
        println!("- Observations: {}", self.observations.len());
        println!("- Success rate: {:.1}%", success_rate);
    }
}

#[derive(Debug)]
pub struct ExecutionTrace {
    pub thoughts: Vec<String>,
    pub actions: Vec<Action>,
    pub observations: Vec<Observation>,
}

#[tokio::main]
async fn main() {
    let mut agent = ReActAgent::new();
    
    // Test different types of tasks
    let tasks = [
        "Find the current CEO of OpenAI",
        "What's the current weather?",
        "Calculate 2+2",
        "Research Python programming",
    ];
    
    for (i, task) in tasks.iter().enumerate() {
        println!("{}", "=".repeat(50));
        println!("Test {}: {}", i + 1, task);
        println!("{}", "=".repeat(50));
        
        let result = agent.solve(task);
        println!("\\nFinal Result: {}", result);
        agent.print_execution_summary();
        
        if i < tasks.len() - 1 {
            println!("\\n{}", "-".repeat(30));
            println!();
        }
    }
}`;

export const sequential_chainingRust = `use async_trait::async_trait;
use serde_json::Value;
use std::time::{Duration, Instant};
use tokio::time::sleep;

#[async_trait]
pub trait ChainStep: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    async fn execute(&self, input: Value) -> Result<Value, Box<dyn std::error::Error + Send + Sync>>;
}

#[derive(Debug, Clone)]
pub struct ChainResult {
    pub step_name: String,
    pub input_data: Value,
    pub output_data: Option<Value>,
    pub duration: Duration,
    pub success: bool,
    pub error: Option<String>,
}

impl ChainResult {
    pub fn success(step_name: String, input: Value, output: Value, duration: Duration) -> Self {
        Self {
            step_name,
            input_data: input,
            output_data: Some(output),
            duration,
            success: true,
            error: None,
        }
    }

    pub fn failure(step_name: String, input: Value, duration: Duration, error: String) -> Self {
        Self {
            step_name,
            input_data: input,
            output_data: None,
            duration,
            success: false,
            error: Some(error),
        }
    }
}

pub struct SequentialChain {
    steps: Vec<Box<dyn ChainStep>>,
    results: Vec<ChainResult>,
}

impl SequentialChain {
    pub fn new() -> Self {
        Self {
            steps: Vec::new(),
            results: Vec::new(),
        }
    }

    pub fn add_step<T: ChainStep + 'static>(&mut self, step: T) {
        self.steps.push(Box::new(step));
    }

    pub async fn execute(&mut self, initial_input: Value) -> Result<Value, Box<dyn std::error::Error + Send + Sync>> {
        println!("Starting sequential chain with {} steps\\n", self.steps.len());
        
        let mut current_input = initial_input;
        self.results.clear();

        for (i, step) in self.steps.iter().enumerate() {
            let start_time = Instant::now();
            
            println!("Step {}: {}", i + 1, step.name());
            println!("Description: {}", step.description());
            println!("Input: {}", current_input);
            
            match step.execute(current_input.clone()).await {
                Ok(output) => {
                    let duration = start_time.elapsed();
                    let result = ChainResult::success(
                        step.name().to_string(),
                        current_input.clone(),
                        output.clone(),
                        duration,
                    );
                    
                    self.results.push(result);
                    
                    println!("Output: {}", output);
                    println!("Duration: {:.3}s", duration.as_secs_f64());
                    println!("✅ Success\\n");
                    
                    current_input = output;
                }
                Err(error) => {
                    let duration = start_time.elapsed();
                    let result = ChainResult::failure(
                        step.name().to_string(),
                        current_input,
                        duration,
                        error.to_string(),
                    );
                    
                    self.results.push(result);
                    
                    println!("❌ Error: {}", error);
                    println!("Duration: {:.3}s\\n", duration.as_secs_f64());
                    
                    return Err(format!("Chain failed at step '{}': {}", step.name(), error).into());
                }
            }
        }

        Ok(current_input)
    }

    pub fn get_results(&self) -> &[ChainResult] {
        &self.results
    }

    pub fn print_summary(&self) {
        if self.results.is_empty() {
            return;
        }

        let total_steps = self.results.len();
        let successful_steps = self.results.iter().filter(|r| r.success).count();
        let total_duration: Duration = self.results.iter().map(|r| r.duration).sum();
        let average_duration = total_duration / total_steps as u32;

        println!("=== Execution Summary ===");
        println!("Total steps: {}", total_steps);
        println!("Successful steps: {}", successful_steps);
        println!("Success rate: {:.1}%", (successful_steps as f64 / total_steps as f64) * 100.0);
        println!("Total duration: {:.3}s", total_duration.as_secs_f64());
        println!("Average step duration: {:.3}s", average_duration.as_secs_f64());
    }
}

// Product Review Chain Implementation
pub struct ResearchFeaturesStep;

#[async_trait]
impl ChainStep for ResearchFeaturesStep {
    fn name(&self) -> &str {
        "Research Features"
    }

    fn description(&self) -> &str {
        "Analyze product features and specifications"
    }

    async fn execute(&self, input: Value) -> Result<Value, Box<dyn std::error::Error + Send + Sync>> {
        sleep(Duration::from_millis(500)).await;
        
        let product_name = input.as_str().unwrap_or("Unknown Product");
        
        let features = serde_json::json!({
            "product_name": product_name,
            "key_features": [
                "High-quality materials",
                "User-friendly interface",
                "Energy efficient",
                "Warranty included"
            ],
            "price": "$99.99",
            "rating": 4.2,
            "category": "Electronics"
        });
        
        Ok(features)
    }
}

pub struct CompetitorAnalysisStep;

#[async_trait]
impl ChainStep for CompetitorAnalysisStep {
    fn name(&self) -> &str {
        "Competitor Analysis"
    }

    fn description(&self) -> &str {
        "Compare features with competitors"
    }

    async fn execute(&self, input: Value) -> Result<Value, Box<dyn std::error::Error + Send + Sync>> {
        sleep(Duration::from_millis(300)).await;
        
        let mut product_data = input;
        
        product_data["competitor_comparison"] = serde_json::json!({
            "price": "Average for category",
            "features": "Above average feature set",
            "quality": "Higher quality than most competitors",
            "value": "Good value for money",
            "market_position": "Top 25% in category"
        });
        
        Ok(product_data)
    }
}

pub struct GenerateReviewStep;

#[async_trait]
impl ChainStep for GenerateReviewStep {
    fn name(&self) -> &str {
        "Generate Review"
    }

    fn description(&self) -> &str {
        "Create initial review based on analysis"
    }

    async fn execute(&self, input: Value) -> Result<Value, Box<dyn std::error::Error + Send + Sync>> {
        sleep(Duration::from_millis(400)).await;
        
        let mut review_data = input;
        
        let product_name = review_data["product_name"].as_str().unwrap_or("Product");
        let price = review_data["price"].as_str().unwrap_or("$0");
        let key_features = review_data["key_features"].as_array().unwrap();
        let features_text = key_features
            .iter()
            .map(|f| f.as_str().unwrap_or(""))
            .collect::<Vec<_>>()
            .join(", ");
        
        let comparison = &review_data["competitor_comparison"];
        let value = comparison["value"].as_str().unwrap_or("Good value");
        let quality = comparison["quality"].as_str().unwrap_or("Good quality");
        let market_position = comparison["market_position"].as_str().unwrap_or("Good position");
        
        let review_text = format!(
            "The {} offers an impressive feature set at {}. \\
             With its {}, it stands out in the market. \\
             {} and {}. The product maintains a {} position in its category.",
            product_name, price, features_text, value, quality, market_position
        );
        
        let rating = review_data["rating"].as_f64().unwrap_or(0.0);
        
        review_data["review_text"] = Value::String(review_text);
        review_data["recommendation"] = Value::String(
            if rating >= 4.0 { "Recommended" } else { "Consider alternatives" }.to_string()
        );
        
        Ok(review_data)
    }
}

pub struct PolishReviewStep;

#[async_trait]
impl ChainStep for PolishReviewStep {
    fn name(&self) -> &str {
        "Polish Review"
    }

    fn description(&self) -> &str {
        "Improve clarity and tone of the review"
    }

    async fn execute(&self, input: Value) -> Result<Value, Box<dyn std::error::Error + Send + Sync>> {
        sleep(Duration::from_millis(200)).await;
        
        let mut polished_data = input;
        
        let rating = polished_data["rating"].as_f64().unwrap_or(0.0);
        let rating_stars = "⭐".repeat(rating as usize);
        let recommendation = polished_data["recommendation"].as_str().unwrap_or("Unknown");
        let review_text = polished_data["review_text"].as_str().unwrap_or("");
        let price = polished_data["price"].as_str().unwrap_or("$0");
        
        let key_features = polished_data["key_features"].as_array().unwrap();
        let features_text = key_features
            .iter()
            .map(|f| f.as_str().unwrap_or(""))
            .collect::<Vec<_>>()
            .join(", ");
        
        let market_position = polished_data["competitor_comparison"]["market_position"]
            .as_str().unwrap_or("Good position");
        let value_assessment = polished_data["competitor_comparison"]["value"]
            .as_str().unwrap_or("Good value");
        
        let final_review = format!(
            "{} {}/5 - {}\\n\\n{}\\n\\n💰 Price: {}\\n🔥 Key Features: {}\\n📊 Market Position: {}\\n💎 Value Assessment: {}",
            rating_stars, rating, recommendation, review_text, price, features_text, market_position, value_assessment
        );

        // Compute word_count BEFORE moving \`final_review\` into the JSON value
        let word_count = final_review.split_whitespace().count() as u64;
        
        polished_data["final_review"] = Value::String(final_review);
        polished_data["publish_ready"] = Value::Bool(true);
        polished_data["word_count"] = Value::Number(word_count.into());
        polished_data["sentiment"] = Value::String(
            if rating >= 4.0 { "positive" } else { "neutral" }.to_string()
        );
        
        Ok(polished_data)
    }
}

pub fn create_product_review_chain() -> SequentialChain {
    let mut chain = SequentialChain::new();
    
    chain.add_step(ResearchFeaturesStep);
    chain.add_step(CompetitorAnalysisStep);
    chain.add_step(GenerateReviewStep);
    chain.add_step(PolishReviewStep);
    
    chain
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== Product Review Chain ===");
    
    let mut review_chain = create_product_review_chain();
    let product_name = Value::String("Smart Widget Pro".to_string());
    
    println!("Creating review for: {}\\n", product_name);
    
    match review_chain.execute(product_name).await {
        Ok(result) => {
            println!("=== Final Result ===");
            if let Some(final_review) = result["final_review"].as_str() {
                println!("{}", final_review);
            }
            println!();
            review_chain.print_summary();
        }
        Err(error) => {
            println!("Review chain failed: {}", error);
        }
    }
    
    Ok(())
}
`;

export const tree_of_thoughtRust = `use std::collections::HashMap;
use uuid::Uuid;

#[derive(Debug, Clone)]
pub struct ThoughtNode {
    pub id: String,
    pub content: String,
    pub score: f64,
    pub children: Vec<String>,
    pub parent: Option<String>,
    pub depth: usize,
}

impl ThoughtNode {
    pub fn new(content: String, score: f64, parent: Option<String>, depth: usize) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            content,
            score,
            children: Vec::new(),
            parent,
            depth,
        }
    }
}

pub struct TreeOfThoughtPlanner {
    nodes: HashMap<String, ThoughtNode>,
    root_id: String,
    best_path: Vec<String>,
}

impl TreeOfThoughtPlanner {
    pub fn new(root_problem: &str) -> Self {
        let root_node = ThoughtNode::new(root_problem.to_string(), 0.0, None, 0);
        let root_id = root_node.id.clone();
        
        let mut nodes = HashMap::new();
        nodes.insert(root_id.clone(), root_node);
        
        Self {
            nodes,
            root_id,
            best_path: Vec::new(),
        }
    }

    pub fn add_thought(&mut self, parent_id: &str, content: &str, score: f64) -> Result<String, String> {
        let parent = self.nodes.get_mut(parent_id)
            .ok_or_else(|| format!("Parent node {} not found", parent_id))?;
        
        let depth = parent.depth + 1;
        let new_node = ThoughtNode::new(content.to_string(), score, Some(parent_id.to_string()), depth);
        let new_id = new_node.id.clone();
        
        parent.children.push(new_id.clone());
        self.nodes.insert(new_id.clone(), new_node);
        
        Ok(new_id)
    }

    pub fn find_best_path(&mut self) -> Vec<String> {
        self.best_path.clear();
        self.explore_path(&self.root_id, Vec::new());
        self.best_path.clone()
    }

    fn explore_path(&mut self, node_id: &str, current_path: Vec<String>) {
        let mut new_path = current_path;
        new_path.push(node_id.to_string());
        
        let node = self.nodes.get(node_id).unwrap();
        
        if node.children.is_empty() {
            // Leaf node - evaluate path
            let path_score = self.calculate_path_score(&new_path);
            let best_score = self.calculate_path_score(&self.best_path);
            
            if path_score > best_score || self.best_path.is_empty() {
                self.best_path = new_path;
            }
            return;
        }

        // Sort children by score and explore best ones first
        let mut sorted_children: Vec<_> = node.children.iter().collect();
        sorted_children.sort_by(|a, b| {
            let score_a = self.nodes.get(*a).unwrap().score;
            let score_b = self.nodes.get(*b).unwrap().score;
            score_b.partial_cmp(&score_a).unwrap()
        });
        
        for child_id in sorted_children {
            self.explore_path(child_id, new_path.clone());
        }
    }

    fn calculate_path_score(&self, path: &[String]) -> f64 {
        if path.is_empty() {
            return 0.0;
        }
        
        let total_score: f64 = path.iter()
            .map(|id| self.nodes.get(id).unwrap().score)
            .sum();
        
        total_score / path.len() as f64
    }

    pub fn print_tree(&self) {
        println!("{}", self.format_tree(&self.root_id, ""));
    }

    fn format_tree(&self, node_id: &str, prefix: &str) -> String {
        let node = self.nodes.get(node_id).unwrap();
        let mut result = format!("{}{} (score: {})\\n", prefix, node.content, node.score);
        
        for (i, child_id) in node.children.iter().enumerate() {
            let is_last = i == node.children.len() - 1;
            let child_prefix = format!("{}{}", prefix, if is_last { "└─ " } else { "├─ " });
            let next_prefix = format!("{}{}", prefix, if is_last { "   " } else { "│  " });
            
            let child = self.nodes.get(child_id).unwrap();
            result.push_str(&format!("{}{} (score: {})\\n", child_prefix, child.content, child.score));
            
            if !child.children.is_empty() {
                result.push_str(&self.format_subtree(child_id, &next_prefix));
            }
        }
        
        result
    }

    fn format_subtree(&self, node_id: &str, prefix: &str) -> String {
        let node = self.nodes.get(node_id).unwrap();
        let mut result = String::new();
        
        for (i, child_id) in node.children.iter().enumerate() {
            let is_last = i == node.children.len() - 1;
            let child_prefix = format!("{}{}", prefix, if is_last { "└─ " } else { "├─ " });
            let next_prefix = format!("{}{}", prefix, if is_last { "   " } else { "│  " });
            
            let child = self.nodes.get(child_id).unwrap();
            result.push_str(&format!("{}{} (score: {})\\n", child_prefix, child.content, child.score));
            
            if !child.children.is_empty() {
                result.push_str(&self.format_subtree(child_id, &next_prefix));
            }
        }
        
        result
    }

    pub fn get_path_to_node(&self, node_id: &str) -> Vec<String> {
        let mut path = Vec::new();
        let mut current_id = Some(node_id.to_string());
        
        while let Some(id) = current_id {
            path.insert(0, id.clone());
            current_id = self.nodes.get(&id).unwrap().parent.clone();
        }
        
        path
    }

    pub fn prune_low_score_branches(&mut self, threshold: f64) {
        let node_ids: Vec<_> = self.nodes.keys().cloned().collect();
        
        for node_id in node_ids {
            if let Some(node) = self.nodes.get_mut(&node_id) {
                node.children.retain(|child_id| {
                    if let Some(child) = self.nodes.get(child_id) {
                        child.score >= threshold
                    } else {
                        false
                    }
                });
            }
        }
    }
}

pub struct TravelPlanner {
    planner: TreeOfThoughtPlanner,
    destination: String,
    budget: f64,
    days: u32,
}

impl TravelPlanner {
    pub fn new(destination: &str, budget: f64, days: u32) -> Self {
        let problem = format!("Plan a {}-day trip to {} with a \${} budget", days, destination, budget);
        let planner = TreeOfThoughtPlanner::new(&problem);
        
        Self {
            planner,
            destination: destination.to_string(),
            budget,
            days,
        }
    }

    pub fn generate_travel_options(&mut self) -> Result<(), String> {
        // Main strategy branches
        let budget_focused = self.planner.add_thought(&self.planner.root_id, "Budget-focused path", 7.0)?;
        let experience_focused = self.planner.add_thought(&self.planner.root_id, "Experience-focused path", 6.0)?;
        let balanced = self.planner.add_thought(&self.planner.root_id, "Balanced path", 9.0)?;
        
        // Budget-focused sub-options
        self.planner.add_thought(&budget_focused, "Hostels + street food", 8.0)?;
        self.planner.add_thought(&budget_focused, "Airbnb + cooking", 7.5)?;
        self.planner.add_thought(&budget_focused, "Couchsurfing + local markets", 6.5)?;
        
        // Experience-focused sub-options
        self.planner.add_thought(&experience_focused, "Luxury hotels + fine dining", 4.0)?;
        self.planner.add_thought(&experience_focused, "Mid-range hotel + restaurants", 5.5)?;
        self.planner.add_thought(&experience_focused, "Boutique hotel + local experiences", 7.0)?;
        
        // Balanced sub-options
        let budget_hotel = self.planner.add_thought(&balanced, "Budget hotel", 8.0)?;
        let dining_mix = self.planner.add_thought(&balanced, "Mix of dining options", 9.0)?;
        let attractions = self.planner.add_thought(&balanced, "Free/low-cost attractions", 9.5)?;
        
        // Further detail for balanced approach
        self.planner.add_thought(&budget_hotel, "2-3 star hotels in good locations", 8.5)?;
        self.planner.add_thought(&dining_mix, "70% local food, 30% restaurants", 9.2)?;
        self.planner.add_thought(&attractions, "Walking tours, museums, parks", 9.8)?;
        
        Ok(())
    }

    pub fn find_best_path(&mut self) -> Vec<String> {
        self.planner.find_best_path()
    }

    pub fn print_tree(&self) {
        self.planner.print_tree();
    }

    pub fn get_node_content(&self, node_id: &str) -> Option<&str> {
        self.planner.nodes.get(node_id).map(|node| node.content.as_str())
    }

    pub fn get_node_score(&self, node_id: &str) -> Option<f64> {
        self.planner.nodes.get(node_id).map(|node| node.score)
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Basic example
    let mut planner = TreeOfThoughtPlanner::new("Plan a 3-day trip to Paris with a $1000 budget");
    
    // Build the thought tree
    let budget_focused = planner.add_thought(&planner.root_id, "Budget-focused path", 7.0)?;
    let experience_focused = planner.add_thought(&planner.root_id, "Experience-focused path", 6.0)?;
    let balanced = planner.add_thought(&planner.root_id, "Balanced path", 9.0)?;
    
    // Budget-focused branches
    planner.add_thought(&budget_focused, "Hostels + street food", 8.0)?;
    planner.add_thought(&budget_focused, "Airbnb + cooking", 7.0)?;
    
    // Experience-focused branches
    planner.add_thought(&experience_focused, "Mid-range hotel + restaurants", 5.0)?;
    planner.add_thought(&experience_focused, "Budget hotel + select dining", 7.0)?;
    
    // Balanced branches
    planner.add_thought(&balanced, "Budget hotel", 8.0)?;
    planner.add_thought(&balanced, "Mix of dining options", 9.0)?;
    planner.add_thought(&balanced, "Free/low-cost attractions", 9.0)?;
    
    println!("Tree of Thought Structure:");
    planner.print_tree();
    
    println!("Best path:");
    let best_path = planner.find_best_path();
    for (i, node_id) in best_path.iter().enumerate() {
        let node = planner.nodes.get(node_id).unwrap();
        println!("{}. {} (score: {})", i + 1, node.content, node.score);
    }
    
    println!("\\n{}", "=".repeat(50));
    println!();
    
    // Advanced travel planner example
    let mut travel_planner = TravelPlanner::new("Tokyo", 1500.0, 5);
    travel_planner.generate_travel_options()?;
    
    println!("Advanced Travel Planning Tree:");
    travel_planner.print_tree();
    
    println!("Optimal travel plan:");
    let optimal_path = travel_planner.find_best_path();
    for (i, node_id) in optimal_path.iter().enumerate() {
        if let (Some(content), Some(score)) = (
            travel_planner.get_node_content(node_id),
            travel_planner.get_node_score(node_id)
        ) {
            println!("{}. {} (score: {})", i + 1, content, score);
        }
    }
    
    Ok(())
}`;

